<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cui36.github.io</id>
    <title>Gridea</title>
    <updated>2022-09-26T04:43:28.016Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cui36.github.io"/>
    <link rel="self" href="https://cui36.github.io/atom.xml"/>
    <subtitle>æ¸©æ•…è€ŒçŸ¥æ–°</subtitle>
    <logo>https://cui36.github.io/images/avatar.png</logo>
    <icon>https://cui36.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[String]]></title>
        <id>https://cui36.github.io/post/string/</id>
        <link href="https://cui36.github.io/post/string/">
        </link>
        <updated>2022-09-11T01:43:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>å¾€å¾€éœ€è¦ä¸¤ä¸ªindexæ¥å®Œæˆæ“ä½œ</p>
</blockquote>
<h1 id="de-duplication">De-duplication</h1>
<h1 id="substring">SubString</h1>
<h2 id="judge-whether-string-a-is-string-bs-substring">judge whether string A is string B's substring</h2>
<blockquote>
<p>Robin Carb: if we can hash the short string to a unique integer, the we can just compare each substring of s1's hashed value -&gt; O(m * n) -&gt; O(n)ï¼Œä¹‹æ‰€ä»¥ä¼šé™ä½ï¼Œæ˜¯å› ä¸ºå°†åŸæ¥çš„å­—ç¬¦ä¸²é€ä½åŒ¹é…æ¢æˆäº†æ»šåŠ¨å“ˆå¸Œç®—æ³•ï¼Œåªéœ€è¦è®¡ç®—å¤´ä¸€ä¸ªhashå€¼ï¼Œä¾¿å¯çŸ¥é“åç»­å­—ç¬¦ä¸²çš„hashå€¼<br>
<img src="https://cui36.github.io/post-images/1663459182111.png" alt="" loading="lazy"></p>
</blockquote>
<pre><code>public int strstr(String large, String small) {
       if (large.length() &lt; small.length()) return -1;
       int targetHashValue = moduleHash(small);
       int seedHashValue = moduleHash(large.substring(0, small.length()));
       for (int i = 0; i &lt;= large.length() - small.length(); i++) {
           if (seedHashValue == targetHashValue) {
               for (int j = 0; j &lt; small.length(); j++) {
                   if (large.charAt(i + j) != small.charAt(j)) {
                       break;
                   }
                   return i; // note
               }
           }
           if (i &lt; large.length() - small.length()) {
               seedHashValue = ((seedHashValue - (large.charAt(i) - 'a') * (26 ^ (small.length() - 1) % 101)) * 26 + (large.charAt(i + small.length()) - 'a')) % 101;  // note
               if (seedHashValue &lt; 0) {  // note
                   seedHashValue += 101;
               }
           }
       }
       return -1;
   }
   public int moduleHash(String a) {
       char[] temp = a.toCharArray();
       int result = 0;
       int size = temp.length - 1;
       for (int i = 0; i &lt; temp.length; i++) {
           result = (result * 26 + (a.charAt(i) - 'a')) % 101;
       }
       return result;
   }
</code></pre>
<h1 id="reversal">Reversal</h1>
<h2 id="å­—ç¬¦ä¸²åè½¬">å­—ç¬¦ä¸²åè½¬</h2>
<p>å®šä¹‰ä¸€å‰ä¸€åä¸¤ä¸ªindexï¼Œäº¤æ¢ï¼Œi &lt; j; æ—¶é—´å¤æ‚åº¦O(n)</p>
<pre><code>public void reverse(char[] input, int start, int end) {
        if (input.length &lt;= 1) {
            return;
        }
        while (start &lt; end) {
            swap(input, start++, end --);
        }
    }
    public void swap(char[] array, int i, int j) {
        char temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
</code></pre>
<h2 id="æ•´ä½“åè½¬ä½†ä¸¾æ­¥ä¸åŠ¨">æ•´ä½“åè½¬ä½†ä¸¾æ­¥ä¸åŠ¨</h2>
<blockquote>
<p>I love yahoo trick -&gt; yahoo love I</p>
</blockquote>
<ol>
<li>å…ˆæ•´ä½“åè½¬</li>
<li>åœ¨å±€éƒ¨åè½¬</li>
</ol>
<pre><code>public String reverseWords(String input) {
        if (input == null || input.length() &lt;= 1) return input;
        // reverse the whole string
        char[] array = input.toCharArray(); // note
        reverse(array, 0, input.length() - 1);
        int start = 0;
        // reverse the words separated
        for (int i = 0; i &lt; input.length(); i++) {
            char temp = array[i];
            if (temp != ' ' &amp;&amp; (i == 0 || array[i - 1] == ' ')) {
                start = i;
            }
            if (temp != ' ' &amp;&amp; (i == input.length() - 1 || array[i + 1] == ' ')) { // note
                reverse(array, start, i);
            }
        }
        return new String(array);
    }
</code></pre>
<h2 id="char-shuffling">char shuffling</h2>
<blockquote>
<p>ABCDEFG1234567 -&gt; A1B2C3D4E5F6G7<br>
æœ´ç´ çš„åšæ³•æ˜¯åˆ©ç”¨mergesortï¼Œä¸è¿‡æˆ‘ä»¬ä¹Ÿå¯ä»¥åˆ©ç”¨I love yahoo trick, time = O(nlogn), å°†å­—ç¬¦ä¸²åˆ†ä¸ºå››ä¸ªåŒºåŸŸï¼Œé¦–å…ˆæ˜¯å‰ä¸€åŠæ˜¯å­—ç¬¦ï¼Œåä¸€åŠæ˜¯å­—æ¯ï¼›ç„¶åæ˜¯åœ¨å‰åä¸¤éƒ¨åˆ†ä¸­å†ä¸€åˆ†ä¸ºäºŒï¼›æ‰€ä»¥ç°åœ¨æ˜¯Aã€Bã€1ã€2å››ä¸ªåŒºåŸŸï¼Œé¦–å…ˆå¯¹Bã€1ä¸¤ä¸ªåŒºåŸŸåštrickï¼Œä¸ºAã€1ã€Bã€2ï¼Œç„¶ååœ¨åˆ†åˆ«é€’å½’è°ƒç”¨A1ï¼ŒB2ï¼Œæ³¨æ„å‚æ•°ï¼›ç›´åˆ°rightå’ŒleftæŒ¨ç€ç»“æŸ</p>
</blockquote>
<pre><code>public char[] shuffling(char[] array) {
       // åˆ†ä¸º4ä¸ªåŒºåŸŸ
        int left = 0;
        int right = array.length - 1;
        convert(array, left, right);
        return array;
    }
    public void convert(char[] array, int left, int right) {
        if (right - left &lt;= 1) {
            return;
        }
        int size = right - left + 1;
        int mid = left + size / 2;
        int leftMid = left + size / 4;
        int rightMid = mid + size / 4;
        reverse(array, leftMid, rightMid - 1);
        reverse(array, leftMid, mid - 1);
        reverse(array, mid, rightMid - 1);

        convert(array, left, left + 2 * (leftMid - left) - 1); // -1æ˜¯å› ä¸ºè¦å°†åä¸€ä½å˜ä¸ºå½“å‰ä½,å¯¹äºå·¦åŠéƒ¨åˆ†é€’å½’
        convert(array,left + 2 * (leftMid - left), right);
    }
</code></pre>
<h1 id="char-remove">Char Remove</h1>
<blockquote>
<p>abc -&gt; (2) -&gt; bca<br>
å€Ÿé‰´ä¸Šä¸€é“é¢˜çš„åšæ³•ï¼Œå°†å­—ç¬¦ä¸²æŒ‰ç…§ç§»åŠ¨æ­¥æ•°è€ƒè™‘æˆä¸¤éƒ¨åˆ†ç„¶åI love yahoo trick</p>
</blockquote>
<h1 id="permutationuse-dfs">Permutation(use DFS)</h1>
<p>&quot;abc&quot; -&gt; [abc, acb, bac, bca, cab, cba]</p>
<pre><code>// è¾“å‡ºå­—ç¬¦ä¸²çš„æ‰€æœ‰æ’åˆ—ï¼Œä¸”å…¶æœ‰é‡å¤å…ƒç´ 
    public void permutation(char[] input, int index) {
        if (index == input.length) { // base case
            System.out.println(input);
            return;
        }
        Set&lt;Character&gt; fixElementInThisLevel = new HashSet&lt;&gt;();
        for (int i = index; i &lt; input.length; i++) {
            if (fixElementInThisLevel.contains(input[i])) {
                continue;
            }
            fixElementInThisLevel.add(input[i]);
            swap(input, index, i);
            permutation(input, index + 1);
            swap(input, index, i);
        }
    }
</code></pre>
<h1 id="decodingencoding">Decoding/encoding</h1>
<p>&quot;aaaaabbbc&quot; -&gt; &quot;a5b3c1&quot;</p>
<blockquote>
<p>æ³¨æ„äº‹é¡¹ï¼šä¸¤æ¬¡å¾ªç¯ï¼Œç¬¬ä¸€éå°†æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°å¤§äºç­‰äºä¸¤æ¬¡çš„letterå’ŒåŠå‡ºç°æ¬¡æ•°æŠ„å½•ä¸‹æ¥ï¼Œæ³¨æ„å…¶å‡ºç°æ¬¡æ•°å¯èƒ½è¶…è¿‡ä¸€ä½æ•°ï¼Œæ‰€ä»¥å¯¹å‡ºç°æ¬¡æ•°ä»åå¾€å‰è®°å½•ï¼Œæ¯”å¦‚23ï¼Œå…ˆè®°å½•3ï¼Œå†è®°å½•2ï¼›ç„¶åå‡ºç°ä¸€æ¬¡çš„letteråªè®°å½•å­—æ¯ï¼›ä¸¤è€…çš„lengthéƒ½è¦ç›¸åº”è®°å½•ï¼›<br>
ç¬¬äºŒæ¬¡å¾ªç¯å¤„ç†åªæœ‰å­—æ¯çš„letterï¼ŒåŠ â€˜1â€™<img src="https://cui36.github.io/post-images/1663896634485.png" alt="" loading="lazy"></p>
</blockquote>
<pre><code>static private String compress(String input) {
        // corner case
        if (input == null || input.isEmpty()) {
            return null;
        }
        char[] array = input.toCharArray();
        // step1: deal with the cases that adjacent letter &gt;= 2
        int fast = 0, slow = 0, newLength = 0;
        while (fast &lt; array.length) {
            int begin = fast;
            while (fast &lt; array.length &amp;&amp; array[fast] == array[begin]) {
                fast++;
            }
            array[slow++] = array[begin]; // æ¯æ¬¡å¾ªç¯å¼€å§‹å‰å…ˆå¤åˆ¶å­—ç¬¦
            if (fast - begin == 1) {
                newLength += 2;  // a 1,ä¸€å…±ä¸¤ä¸ªå­—ç¬¦ï¼Œè€Œä¸”ä¸å˜
            } else {
                int len = copyDigits(array, slow, fast - begin); // è®¡ç®—å¤§äº2çš„å­—ç¬¦æ•°ï¼Œè¿”å›å…¶é•¿åº¦
                slow += len; //  slowç°åœ¨æ˜¯æœ€åä¸€ä¸ªä½ç½®çš„åä¸€ä½
                newLength += len + 1; // æ•°å­—ä½æ•° + ä¸€ä¸ªå­—ç¬¦
            }
        }
        // step2: deal with the single letter
        char[] result = new char[newLength];
        fast = slow - 1;
        slow = newLength - 1;
        while (fast &gt;= 0) {
            if (Character.isDigit(array[fast])) {
                while (fast &gt;= 0 &amp;&amp; Character.isDigit(array[fast])) {
                    result[slow--] = array[fast--];
                }
            } else {
                result[slow--] = '1';
            }
            result[slow--] = array[fast--];
        }
        return new String(result);
    }
    static public int copyDigits(char[] input, int index, int count) {
        int len = 0;
        for (int i = count; i &gt; 0 ; i /= 10) {
            index++;
            len++;
        }
        for (int i = count; i &gt; 0 ; i /= 10) {
            int digit = i % 10;
            input[--index] = (char) ('0' + digit);
        }
        return len;
    }
</code></pre>
<blockquote>
<p>å¦‚æœæ˜¯é€†è¿‡ç¨‹ï¼Œæ³¨æ„å¤„ç†0çš„æƒ…å†µ</p>
</blockquote>
<h1 id="longest-substring">Longest substring</h1>
<p>æœ€é•¿æ— é‡å¤å­—ç¬¦çš„å­åºåˆ—ï¼šabcdea -&gt; abcde -&gt; 5</p>
<blockquote>
<p>é‡‡ç”¨æ»‘åŠ¨çª—å£çš„æ€æƒ³ï¼Œè®¾ç«‹slowï¼Œfastä¸¤ä¸ªæŒ‡é’ˆï¼Œæ¯æ¬¡é‡è§setä¸­ä¸åŒ…å«çš„å­—ç¬¦ï¼Œåˆ™ç§»åŠ¨slowæŒ‡é’ˆï¼›é‡è§setä¸­åŒ…å«çš„å­—ç¬¦ï¼Œåˆ å»å­—ç¬¦å¹¶ç§»åŠ¨slow</p>
</blockquote>
<pre><code>public int longest(String input) {
        if (input == null || input.isEmpty()) {
            return -1;
        }
        Set&lt;Character&gt; window = new HashSet&lt;&gt;();
        int slow = 0, fast = 0, longest = 0;
        while (fast &lt; input.length()) {
            // if å‡ºç°é‡å¤çš„å­—ç¬¦ï¼Œåˆ é™¤ç¬¬ä¸€ä¸ªï¼Œå¹¶å‘åç§»åŠ¨slowæŒ‡é’ˆ
            if (window.contains(input.charAt(fast))) {
                window.remove(input.charAt(slow++));
            } else { // è‹¥ä¸ç„¶ï¼Œæ»‘åŠ¨fastæŒ‡é’ˆä½¿å…¶åŒ…å«æœ€è¿œçš„å­—ç¬¦
                window.add(input.charAt(fast++));
                longest = Math.max(longest, fast - slow);
            }
        }
        return longest;
    }
</code></pre>
<h1 id="matching">Matching</h1>
<h2 id="allanagrams">allAnagrams</h2>
<p>l = &quot;abcbac&quot;, s = &quot;ab&quot;, return [0, 3]</p>
<blockquote>
<p>ä¸ºäº†ä½¿å¾—æ—¶é—´å¤æ‚æ˜¯O(n),æ­¤é¢˜ä»é‡‡ç”¨æ»‘åŠ¨çª—å£æ¥è§£å†³é—®é¢˜ï¼Œå¹¶ä¸”ä¸åŒäºnativeçš„åšæ³•ï¼Œæˆ‘ä»¬å°†Mapçš„å€¼è®¾ä¸ºè¿˜ç¼ºå¤šå°‘ä¸ªè¯¥å­—æ¯ï¼Œæ¯æ¬¡é‡è§æ–°çš„ï¼Œå°±å°†å…¶å€¼-1ï¼Œmatch++ï¼›å½“å½“å‰æŒ‡é’ˆè¶…è¿‡loå­—ç¬¦ä¸²é•¿åº¦æ—¶ï¼Œæˆ‘ä»¬å°†è¿›è¡Œçª—å£çš„ç§»åŠ¨ï¼Œæ­¤æ—¶å°†çª—å£æœ€å·¦ä¾§å­—ç¬¦çš„mapå€¼+1ï¼Œmatch--ï¼›æ¯æ¬¡å¾ªç¯ç»“æŸå¦‚æœmatch == map.size(),è¯´æ˜æ‰¾åˆ°ä¸€ä¸ªæœ‰æ•ˆé…å¯¹</p>
</blockquote>
<pre><code>static public List&lt;Integer&gt; allAnagrams(String sh, String lo) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        // corner case
        if (lo == null || lo.length() == 0) {
            return result;
        }
        if (lo.length() &lt; sh.length()) {
            return result;
        }
        Map&lt;Character, Integer&gt; map = countMap(sh);
        int match = 0;
        for (int i = 0; i &lt; lo.length(); i++) {
            char tmp = lo.charAt(i);
            Integer count = map.get(tmp);
            if (i &gt;= sh.length()) {
                tmp = lo.charAt(i - sh.length());
                count = map.get(tmp);
                if (count != null) {
                    map.put(tmp, count + 1);
                    if (count == 0) {
                        match--;
                    }
                }
            }
            tmp = lo.charAt(i);
            count = map.get(tmp);
            if (count != null) {
                map.put(tmp, count - 1);
                if (count == 1) {
                    match++;
                }
            }

            if (match == map.size()) {
                result.add(i - sh.length() + 1);
            }
        }
        return result;
    }
    static public Map&lt;Character, Integer&gt; countMap(String s) {
        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
        for (char ch : s.toCharArray()) {
            Integer count = map.get(ch);
            if (count == null) {
                map.put(ch, 1);
            } else {
                map.put(ch, ++count);
            }
        }
        return map;
    }
</code></pre>
<h2 id="longestconsecutiveones">longestConsecutiveOnes</h2>
<p>flip 0s at index 2 and 3, then the array becomes [1,1,1,1,1,1,1,0,0,0], so that the length of longest subarray that contains only integer 1 is 7.</p>
<blockquote>
<p>High level: å¯¹äºæ¯ä¸€ä¸ªå¯èƒ½çš„windowçš„fast indexï¼Œæ˜¯çš„slowä¸fastä¹‹é—´çš„å­—æ¯ä¸è¶…è¿‡kä¸ªzeroï¼Œæ‰¾åˆ°æœ€è¿œçš„slowæ›´æ–°fast - slow + 1</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ä¸‰äººè¡Œï¼Œå¿…æœ‰æˆ‘å¸ˆ]]></title>
        <id>https://cui36.github.io/post/san-ren-xing-bi-you-wo-shi/</id>
        <link href="https://cui36.github.io/post/san-ren-xing-bi-you-wo-shi/">
        </link>
        <updated>2022-09-06T16:36:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ä¸è‹ä¼Šä¿¡å­¦é•¿ä¸€å¸­è°ˆ202297">ä¸è‹ä¼Šä¿¡å­¦é•¿ä¸€å¸­è°ˆï¼Œ2022.9.7</h1>
<blockquote>
<p>æœ¬æ¥æ˜¯å»å‚åŠ Bloombergçš„ç ”è®¨ä¼šï¼Œç»“æœä¼šè®®ç”±å¤§æ•™å®¤æ¬åˆ°äº†å®¤å¤–ï¼Œä»20åº¦çš„åç¥¨æ¢åˆ°äº†35åº¦çš„ç«™ç¥¨ï¼Œå¿ƒæƒ…è‡ªç„¶ä¸å¥½å—ã€‚åˆ°äº†å¹¿åœºå·²æœ‰ç™¾åä½åŒå­¦é›†ç»“äºæ­¤ï¼Œæ‹‰ç€Engineerå’ŒHRè°ˆå¤©è¯´åœ°ï¼Œæˆ‘ä¼¼ä¸€ä½å±€å¤–äººä¾§è€³å€¾å¬ï¼Œå‡è£…å¬æ‡‚ï¼Œå‡è£…ä¸æˆ‘æœ‰å…³ã€‚ä½†æˆ‘ç”Ÿå‘½çŸ­æš‚ï¼Œæ—¶é—´æœ‰é™ï¼Œä¸èƒ½å†æ™’å¤ªé˜³äº†ï¼åˆšè¦å»å›¾ä¹¦é¦†æ‰¾åº·å°‘ï¼Œå°±é‡è§ä¸€ä½æ–‡è´¨å½¬å½¬çš„äºšæ´²é¢å­”åœ¨å’Œç¾å›½åŒå­¦äº¤è°ˆç€ï¼Œä¾§è€³å€¾å¬äº†ä¼šï¼Œè¿™ä½äºšæ´²é¢å­”åº”è¯¥æ˜¯ç ”äºŒï¼Œç›´ç³»å­¦é•¿ï¼Œæˆ‘äºæ˜¯åŠ å…¥äº†ç¾¤èŠ<br>
â€œAre you guys graduate students as well?â€<br>
â€œYes, this my second year ...... from China...â€ ç­‰ç¾å›½æœ‰äººèµ°åï¼Œæˆ‘ç´§ç´§â€œæŠ“ä½äº†â€å­¦é•¿</p>
</blockquote>
<h2 id="å…³äºinterhsip">å…³äºinterhsip</h2>
<ol>
<li>æŠ•é€’æ—¶é—´ï¼šå­¦é•¿æ˜¯ä»Šå¹´1æœˆæŠ•é€’ï¼Œä¸è¿æ°”æœ‰å…³ï¼Œä¸å½¢åŠ¿æœ‰å…³ã€‚ä½†æ˜¯èƒ½æ—©æŠ•é€’å°±æ—©æŠ•é€’ã€‚</li>
<li>å…³äºå¦‚ä½•æŠ•é€’ï¼Ÿå­¦é•¿æ¨èçš„è½¯ä»¶å¯ä»¥çœ‹çœ‹</li>
<li>å†…æ¨å¦‚ä½•çœ‹ï¼Ÿä¸€èˆ¬åœ°é‡Œä¼šå›å¤æ›´å¿«ï¼Œæ‰€ä»¥å¯ä»¥å»åœ°é‡Œçœ‹çœ‹</li>
<li>å…³äºé¢ç»ï¼šåœ°é‡Œ -&gt; å…¬å¸ -&gt; é¢ç»ï¼Œä¸€èˆ¬å¯ä»¥åˆ·åˆ°çœŸé¢˜ï¼ˆAmazoné¢ç»æ¦‚ç‡æé«˜ï¼‰</li>
<li>å…³äºç®—æ³•ï¼šå¤šèƒŒæ¨¡ç‰ˆï¼Œåˆ·é¢˜ä¼šæ›´å¿«ï¼›å›¾è¦å¤šåˆ·ï¼ŒDPå¯ä»¥æŒæ¡åˆ°ä¸­ç­‰ï¼ˆfor Amazon onlyï¼‰ï¼›å¿…åˆ·é¢˜ï¼š75é“ï¼Œä¸€å®šè¦ç†Ÿç»ƒæŒæ¡</li>
<li>å¯ä»¥å’ŒåŒå­¦ä¸€èµ·åˆ·é¢˜</li>
<li>æœ€åä¸€å­¦æœŸå¦‚æœåªé€‰äº†ä¸€é—¨å­¦åˆ†ï¼Œå¯ä»¥å’Œå­¦é™¢å•†é‡å®ä¹ ï¼Œè¿™æ ·è‡ªå·±å°±æœ‰ä¸‰æ®µå®ä¹ æœºä¼šäº†</li>
</ol>
<h2 id="å…³äºç”Ÿæ´»">å…³äºç”Ÿæ´»</h2>
<ol>
<li>åŠ å·ã€æ¹¾åŒºç”Ÿæ´»è´¹ç¡®å®é«˜</li>
<li>å°‘åˆ·Bç«™ï¼Œå¤šåˆ·Youtube</li>
<li>èƒ½ä¸¤å¹´æ¯•ä¸šå°½é‡ä¸¤å¹´æ¯•ä¸šï¼Œè¿™æ ·å°±æœ‰æ›´å¤šçš„æ—¶é—´å¹²è‡ªå·±æƒ³è¦çš„äº‹æƒ…</li>
</ol>
<h2 id="å…³äºcarrier-fair">å…³äºCarrier fair</h2>
<ol>
<li>ä¸€å®šè¦æ—©ç‚¹æ¥ï¼Œé—®é¢è¯•å®˜è‡ªå·±æƒ³é—®çš„é—®é¢˜ï¼šæ‚¨èƒ½ä»‹ç»ä¸‹å…¬å¸å—ï¼Ÿç½‘ä¸Šçš„sdeå’Œfull stackæœ‰ä»€ä¹ˆåŒºåˆ«å—ï¼Ÿè¿™æ˜¯æˆ‘çš„ç®€å†ï¼Œæ‚¨è§‰å¾—æˆ‘æ›´é€‚åˆåšä»€ä¹ˆå‘¢ï¼Ÿæˆ‘è¿˜éœ€è¦è¡¥å……ä»€ä¹ˆä¸œè¥¿å‘¢ï¼Ÿè‡ªå·±æ‰“å°ï¼Œç„¶åæœ€åè¯´è¿™æ˜¯æˆ‘çš„ç®€å†ï¼Œæˆ‘å¯ä»¥ä¸å¯ä»¥æ”¾åœ¨æ‚¨è¿™é‡Œå‘¢ï¼Ÿç›´æ¥æ”¾ç€ï¼Œåç»­å‘ç”Ÿä»€ä¹ˆå°±ä¸ç®¡æˆ‘ä»¬çš„äº‹äº†
<blockquote>
<p>å¤šå¬TEDç¤¾äº¤ç¤¼ä»ªï¼šå¦‚ä½•é—®å‡ºè‡ªå·±æƒ³é—®çš„é—®é¢˜ï¼Ÿå¦‚ä½•æ›´åˆé€‚çš„è¡¨è¾¾ï¼Ÿ...</p>
</blockquote>
</li>
<li>å°±ç®—æ˜¯ä¸sponsorçš„ä¹Ÿå¯ä»¥é—®ä»–èƒ½ä¸èƒ½å®ä¹ </li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Macç©æ³•]]></title>
        <id>https://cui36.github.io/post/mac-wan-fa/</id>
        <link href="https://cui36.github.io/post/mac-wan-fa/">
        </link>
        <updated>2022-09-05T09:40:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vim">Vim</h1>
<ol>
<li>é…ç½®é«˜äº®å’Œæ˜¾ç¤ºè¡Œæ•° https://blog.csdn.net/zizle_lin/article/details/81530311</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Graph]]></title>
        <id>https://cui36.github.io/post/graph-search/</id>
        <link href="https://cui36.github.io/post/graph-search/">
        </link>
        <updated>2022-08-28T04:35:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="graphæ ¸å¿ƒæ€æƒ³æ€»ç»“">Graphæ ¸å¿ƒæ€æƒ³æ€»ç»“</h1>
<ol>
<li>how to represent a Graph<br>
a. é‚»æ¥çŸ©é˜µ / é‚»æ¥è¡¨<br>
b. List&lt;List<Integer>&gt;</li>
<li>How to model a problem to graph problem: æ„å»ºç‚¹å’Œè¾¹çš„å…³ç³»</li>
<li>key problemï¼štraverse this graph by some way</li>
<li>How many ways?</li>
<li>è€ƒè™‘æ ¸å¿ƒï¼šå»é‡</li>
</ol>
<h1 id="graph-search">Graph Search</h1>
<pre><code>class GrapgNode {
    int value;
    string name;
    ...
    List&lt;GraphNode&gt; neighbors; 
}
</code></pre>
<h2 id="bfs1">BFS1</h2>
<blockquote>
<p>é€‚ç”¨é—®é¢˜ï¼šåˆ†å±‚æ‰“å°ï¼ŒåŒå±‚å…³ç³»<br>
expand and generate,ä¸”æ¯ä¸ªnodeåªèƒ½è¢«pollä¸€æ¬¡ä¸”ä»…ä¸€æ¬¡ï¼ˆå¯ä»¥ç”¨Hashsetè®°å½•ï¼‰ï¼Œä¸èƒ½é‡æ–°generate<br>
æ•°æ®ç»“æ„ï¼šQueue</p>
</blockquote>
<ol>
<li>initial state(root)</li>
<li>expand a node, poll, visit, print ...</li>
<li>generate nodes: reach out to its neighboring nodes</li>
<li>deduplicate: expand and generate for only once</li>
</ol>
<pre><code>ï¼ˆå±‚åºéå†ï¼‰
public List&lt;List&lt;Integer&gt;&gt; layerByLayer(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        if (root == null) return result;
        Queue&lt;TreeNode&gt; helper = new LinkedList&lt;&gt;();
        helper.offer(root);
        // result.add(root.key);
        while (!helper.isEmpty()) {
            int size = helper.size();  // æ¯è¡Œçš„å…ƒç´ 
            List&lt;Integer&gt; layerNode = new ArrayList&lt;&gt;();
            for (int i = 0; i &lt; size; i++) {
                TreeNode curr = helper.poll();
                if (curr.left != null) {
                    helper.offer(curr.left);
                }
                if (curr.right != null) {
                    helper.offer(curr.right);  // note! æ˜¯currä¸æ˜¯root
                }
                layerNode.add(curr.key);
            }
            result.add(layerNode);
        }
        return result
</code></pre>
<blockquote>
<p>å¯ä»¥çœ‹å‡ºï¼Œå¦‚æœæœ‰çš„ä¾‹é¢˜éœ€è¦åˆ©ç”¨BFSï¼Œå…ˆåˆ›å»ºä¸€ä¸ªQueueï¼Œç„¶åwhileå¾ªç¯æ¡ä»¶æ˜¯ä¸ä¸ºç©ºï¼Œå¾ªç¯ä½“å†…æ ¹æ®æ¡ä»¶é€‰æ‹©ä½•æ—¶åŠ å…¥ã€ä½•æ—¶pollé˜Ÿåˆ—ä¸­å…ƒç´ </p>
</blockquote>
<pre><code>// åˆ¤æ–­æ˜¯å¦æ˜¯å®Œå…¨äºŒå‰æ ‘
public boolean isCompleted(TreeNode root) {
        if (root == null) return true; // null å’Œ å•èŠ‚ç‚¹
        boolean flag = false;  // flagä»£è¡¨any of its child is empty
        Queue&lt;TreeNode&gt; dfs = new LinkedList&lt;&gt;();
        dfs.offer(root);
        while (!dfs.isEmpty()) {
            TreeNode curr = dfs.poll();
            if (curr.left == null) {
                flag = true;
            } else if (flag) { // å¦‚æœå·¦å­æ ‘ä¸ä¸ºç©ºï¼Œä¸”flagä¸ºç©ºï¼Œä»£è¡¨ä¹‹å‰å±‚[1,nï¼‰æœ‰ç©ºçš„ï¼Œä¸æ»¡è¶³å®šä¹‰ã€‚æ³¨æ„æˆ‘ä»¬æ˜¯å…ˆåˆ¤æ–­çš„å·¦å­æ ‘ï¼Œå¦‚æœæ˜¯è¯¥èŠ‚ç‚¹æˆ–ä¹‹åèŠ‚ç‚¹æœ‰ç©ºå­æ ‘å°†åœ¨ä¹‹ååˆ¤æ–­ï¼Œä¸æ»¡è¶³è¿™ä¸ªifæ¡ä»¶ï¼›
                return false; 
            } else {
                dfs.offer(curr.left);
            }
            if (curr.right == null) {
                flag = true;
            } else if (flag) { // å³å­æ ‘å­˜åœ¨ï¼Œä½†ä¹‹å‰å±‚æœ‰ç©ºçš„
                return false;
            } else {
                dfs.offer(curr.right);
            }
        }
        return true;
    }
// full true: ä¸èƒ½æœ‰åº¦ä¸º1çš„èŠ‚ç‚¹
while (!dfs.isEmpty()) {
            TreeNode curr = dfs.poll();
            if (curr.left == null) {
                if (curr.right != null) {
                    return false;
                }
            } else {
                if (curr.right == null) {
                    return false;
                } else {
                    dfs.offer(curr.left);
                    dfs.offer(curr.right);
                }
            }
        }
</code></pre>
<h2 id="best-first-search">Best First Search</h2>
<blockquote>
<p>é€‚ç”¨é—®é¢˜ï¼šshortest path, min/max k elements<br>
input a node, output the shortest path to all the rest nodes(ç‚¹åˆ°é¢çš„ç®—æ³•) e.g. åŒ—äº¬åˆ°æ‰€æœ‰å…¶ä»–åŸå¸‚æœ€çŸ­è·ç¦»<br>
æ•°æ®ç»“æ„ï¼šPriority Queue(ä¸BFSå”¯ä¸€çš„åŒºåˆ«ï¼Œè€Œä¸”BFSä¸€èˆ¬è¦æ›´éå†ç»“æŸï¼Œä½†æ˜¯BFS2ä¸ä¸€å®šè¦å°†æ‰€æœ‰å…ƒç´ éå†å®Œï¼Œå¦‚æœä¸è¦éå†å®Œï¼Œå°±ç›´æ¥forå¾ªç¯å°±å¥½äº†ï¼Œå¾ªç¯æ¬¡æ•°æ˜¯é™¤å»å¾ªç¯å¤–çš„ä¸€æ¬¡åçš„k - 1)</p>
</blockquote>
<ol>
<li>initial state: start nodeï¼Œæœ‰å¯èƒ½æ˜¯æ•°ç»„ç¬¬ä¸€ä¸ªä½ç½®</li>
<li>node expand and generate role, cost(node) = cost(parent node) + c(parent of node, node)
<blockquote>
<p>maintain a hashset &lt;'GraphNode'&gt; to mark whether the nodes has been generate before</p>
</blockquote>
</li>
<li>end conditionï¼Œæ‰€æœ‰ç‚¹éƒ½éå†ï¼Œå³p_queueå˜ç©º</li>
<li>Dijkstra's algrothim property:<br>
a. one node can be only expand once<br>
b. one node can be generated more than once(re-caculate cost)<br>
c. all the pop costs are non-decreasing<br>
d. time complexity = O(E*logV)<br>
e. when a node is poped out for expansion, the value is fixed from the start node</li>
<li>deduplicate is important in this question: ä¸€èˆ¬æ–¹æ³•æ˜¯å®šä¹‰ä¸€ä¸ªboolean[][] visited, å¦‚æœgeneratedæˆ‘ä»¬å°±å°†å…¶ä¸­å¯¹åº”ä½ç½®çš„å…ƒç´ è®¾ä¸ºtrueï¼Œè€Œä¸”åœ¨æ¯æ¬¡å°†æ–°å…ƒç´ åŠ å…¥é˜Ÿåˆ—å‰éœ€è¦åˆ¤æ–­æ˜¯ä¸æ˜¯true</li>
</ol>
<pre><code>// å¯»æ‰¾æ•°ç»„ä¸­ç¬¬kå°çš„å…ƒç´ ï¼Œä¸”æ•°ç»„ä»å·¦åˆ°å³é€’å¢ï¼Œä»ä¸Šåˆ°ä¸‹é€’å¢
public static class Cell {
        int row;
        int column;
        int value;

        Cell(int row, int column, int value) {
            this.row = row;
            this.column = column;
            this.value = value;
        }
    }
    public int kthSmallest(int[][] matrix, int k) {
        int rows = matrix.length;
        int columns = matrix[0].length;
        PriorityQueue&lt;Cell&gt; minHeap = new PriorityQueue&lt;Cell&gt;(k, new Comparator&lt;Cell&gt;() { // åˆ›å»ºæ–°çš„æ•°æ®ç»“æ„
            @Override
            public int compare(Cell o1, Cell o2) {
                if (o1.value == o2.value) return 0;
                return o1.value &lt; o2.value ? -1 : 1;
            }
        });
        // set generated cell to justify whether it is generated before
        boolean[][] visited = new boolean[rows][columns];
        minHeap.offer(new Cell(0, 0, matrix[0][0]));
        visited[0][0] = true;
        for (int i = 0; i &lt; k - 1; i++) {
            Cell cur = minHeap.poll();  // pop one element from at most 2* k p-queue, O(log2k)
            // add its neighbors
            // if not boundary &amp;&amp; if not generated before
            if (cur.row + 1 &lt; rows &amp;&amp; !visited[cur.row + 1][cur.column]) {
                minHeap.offer(new Cell(cur.row + 1, cur.column, matrix[cur.row + 1][cur.column])); // O(log2k)
                visited[cur.row + 1][cur.column] = true;
            }
            if (cur.column + 1 &lt; columns &amp;&amp; !visited[cur.row][cur.column + 1]) {
                minHeap.offer(new Cell(cur.row, cur.column + 1, matrix[cur.row][cur.column + 1]));
                visited[cur.row][cur.column + 1] = true;
            }
        }
        return minHeap.peek().value;
    }
// æ—¶é—´å¤æ‚åº¦ä¸€å…±æ˜¯O(klogk)
</code></pre>
<h2 id="dfs">DFS</h2>
<blockquote>
<p>åŸºæœ¬æ–¹æ³•ï¼šç”»Recursion Tree</p>
<ol>
<li>æ¯å±‚ä»£è¡¨ä»€ä¹ˆæ„ä¹‰ï¼ŸDFSæœ‰å¤šå°‘å±‚ï¼Ÿ</li>
<li>æ¯å±‚æœ‰å‡ ä¸ªçŠ¶æ€/caseï¼Ÿ<br>
Noteï¼šåƒåå®ˆæ’å®šå¾‹ï¼Œå³å›åˆ°æ¯èŠ‚ç‚¹å‰ï¼Œä¸€å®šè¦è¿˜åŸæˆåŸå§‹çŠ¶æ€</li>
</ol>
</blockquote>
<ol>
<li>ç»å…¸ä¾‹é¢˜1ï¼šè¾“å‡ºä¸€ä¸ªå­—ç¬¦ä¸²å†…æ‰€æœ‰çš„å­—ç¬¦æ’åˆ—ç»„åˆæ–¹å¼Permutation</li>
<li>Method: swap - swap,å³æ¯æ¬¡éƒ½æŠŠä¸€ä¸ªå…ƒç´ å›ºå®šåœ¨è¿™ä¸€å±‚è¯¥å›ºå®šçš„ä½ç½®ä¸Š</li>
<li>Recursion Tree: æ¯ä¸€å±‚ä»£è¡¨è¯¥å›ºå®šçš„å…ƒç´ ä½ç½®ï¼Œ[0, index] è¡¨ç¤ºå›ºå®šå¥½çš„åŒºé—´ï¼Œ[index...array.length - 1]è¡¨ç¤ºå°šæœªç¡®å®šä½ç½®ï¼Œä½†æ˜¯å½“å±‚å¯ä»¥è€ƒè™‘è¢«å›ºå®šæ¥çš„å…ƒç´ ï¼Œindexè¡¨ç¤ºå½“å±‚å¯ä»¥è€ƒè™‘ç¬¬ä¸€ä¸ªæ”¾è¿‡æ¥çš„å…ƒç´ </li>
</ol>
<pre><code>public class Solution {
  public List&lt;String&gt; permutations(String input) {
    // Write your solution here
    List&lt;String&gt; result = new ArrayList&lt;String&gt;(); 
    DFS(input.toCharArray(), 0, result);
    return result;
  }
  public void DFS(char[] input, int index, List&lt;String&gt; result) {
    if (index == input.length) {
      result.add(new String(input));
      return;
    }
    for (int i = index; i &lt; input.length; i++) {
      swap(input, index, i);
      DFS(input, index + 1, result);
      swap(input, index, i);
    }
  }
  public void swap(char[] input, int i, int j) {
    char tmp = input[i];
    input[i] = input[j];
    input[j] = tmp;
  }
} // O(n!)
// å¦‚æœè¾“å…¥å­—ç¬¦æ•°ç»„æœ‰é‡å¤å…ƒç´ ï¼Œåˆ™å¯ä»¥è®¾ç«‹ä¸€ä¸ªset
</code></pre>
<h3 id="dfs-è¿é€šæ€§">DFS è¿é€šæ€§</h3>
<h3 id="dfsè§£å†³topological-order">DFSè§£å†³Topological order</h3>
<h3 id="dfsè§£å†³å›¾ä¸Šçš„è·¯å¾„é—®é¢˜">DFSè§£å†³å›¾ä¸Šçš„è·¯å¾„é—®é¢˜</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LateXå¸¸ç”¨è¡¨è¾¾å¼]]></title>
        <id>https://cui36.github.io/post/latex-chang-yong-biao-da/</id>
        <link href="https://cui36.github.io/post/latex-chang-yong-biao-da/">
        </link>
        <updated>2022-08-27T10:51:57.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>\vspace{-4.0mm} ä¸ä¸‹ä¸€è¡Œçš„è·ç¦»</li>
<li>\setlength\tabcolsep{1ex} è®¾ç½®å·¦è¾¹è·</li>
<li>è®¾ç½®å­—ä½“æ—¶\fontsize{8.5pt}{1em} åˆ†åˆ«æ˜¯å­—ä½“å¤§å°ï¼Œè¡Œé—´è·ï¼Œå¦‚æœè¦ç”Ÿæ•ˆï¼Œéœ€è¦åŠ  \selectfont å…³é”®å­—</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[About Java]]></title>
        <id>https://cui36.github.io/post/about-java/</id>
        <link href="https://cui36.github.io/post/about-java/">
        </link>
        <updated>2022-08-14T09:26:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ä¸€äº›æ•°ç»„çš„å®šä¹‰">ä¸€äº›æ•°ç»„çš„å®šä¹‰</h1>
<ol>
<li>è¿”å›intå‹æ•°ç»„</li>
</ol>
<pre><code>return new int[]{thisLength, digit};
</code></pre>
<ol start="2">
<li>åˆå§‹åŒ–Stringæ•°ç»„</li>
</ol>
<pre><code>String str = new String(&quot;x2y0i0z3&quot;);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[About interview]]></title>
        <id>https://cui36.github.io/post/about-interview/</id>
        <link href="https://cui36.github.io/post/about-interview/">
        </link>
        <updated>2022-08-13T09:10:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="è®²è§£code-a-complete-answer-must-include">è®²è§£code (a complete answer must include)</h1>
<ol>
<li>Document your assumptions</li>
<li>Explain your approach and how to intent to solve</li>
<li>Provide code comments, like <em>code frame</em></li>
<li>Explain the complexity</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Coding small problem]]></title>
        <id>https://cui36.github.io/post/coding-small-problem/</id>
        <link href="https://cui36.github.io/post/coding-small-problem/">
        </link>
        <updated>2022-08-12T18:01:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="java-if-çš„ä½œç”¨åŸŸ">Java if çš„ä½œç”¨åŸŸ</h1>
<ol>
<li>åŸºæœ¬çš„ï¼šif ä¸ else if, elseç»„åˆï¼Œå…¶æ‰§è¡Œé¡ºåºæ²¡ä»€ä¹ˆé—®é¢˜ï¼›</li>
<li>å½“å¤šä¸ªifç›¸é‡ï¼Œå…¶æ‰§è¡Œé¡ºåºæ˜¯ä»ä¸Šå¾€ä¸‹æ‰§è¡Œï¼Œå½“ç¬¬ä¸€ä¸ªifæ»¡è¶³æ¡ä»¶ï¼Œå¦‚æœå…¶è¯­å¥å†…æœ‰returnï¼Œåˆ™ç»“æŸï¼›å¦‚æœæ²¡æœ‰returnï¼Œä¸”ä¹‹åçš„ifæ¡ä»¶äº¦æ»¡è¶³ï¼Œåˆ™å‡ä¼šæ‰§è¡Œï¼›å…·ä½“æ¡ˆä¾‹è¯·è§recursionä¸­çš„è°ƒåº¦ï¼›</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ç¼–ç¨‹å°tips]]></title>
        <id>https://cui36.github.io/post/bian-cheng-xiao-tips/</id>
        <link href="https://cui36.github.io/post/bian-cheng-xiao-tips/">
        </link>
        <updated>2022-08-10T01:48:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="æŒ‡é’ˆ">æŒ‡é’ˆ</h1>
<h2 id="å¿«æ…¢æŒ‡é’ˆ">å¿«æ…¢æŒ‡é’ˆ</h2>
<blockquote>
<p>å€ŸåŠ©é€Ÿç‡ç›¸å·®ä¸€å€çš„ç‰¹æ€§ï¼Œæ‰¾åˆ°linkedlistä¸­é—´å…ƒç´ </p>
</blockquote>
<pre><code>node getMiddle(node h) {
        if (h == null || h.next == null) {
            return h;
        }
        node slow = head, fast = head;
        while (fast.next != null &amp;&amp; fast.next.next != null) { // æŒ‰ç…§æ­¥æ•°ä¾æ­¤åˆ¤æ–­ï¼Œåªæœ‰å½“è¿‘çš„æœ‰æ•ˆï¼Œè¿œçš„æ‰ä¸ä¼šå‡ºç°npe
            slow = slow.next; // æ—¥æ‹±ä¸€å’
            fast = fast.next.next;  // æ—¥æ‹±ä¸¤å’
        }
        return slow;
    }
</code></pre>
<blockquote>
<p>åˆ¤æ–­æ˜¯å¦æœ‰ç¯</p>
</blockquote>
<pre><code>public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) return false;
        ListNode slow = head, fast = head;
        while (fast.next != null &amp;&amp; fast.next.next != null) {   // &amp;&amp; å‰åçš„é¡ºåºä¸èƒ½å˜
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) return true;
        }
        return false;
    }
</code></pre>
<h2 id="dummy-head">Dummy head</h2>
<blockquote>
<p>not must, but sometime handy</p>
</blockquote>
<ol>
<li>the head could be changed</li>
<li>not sure which node will be head</li>
</ol>
<blockquote>
<p>merge two Sorted array</p>
</blockquote>
<pre><code>public ListNode merge(ListNode one, ListNode two) {
        if (one == null) return two;
        if (two == null) return one;
        ListNode dummyHead = new ListNode(0);
        ListNode curr = dummyHead;
        while (one != null &amp;&amp; two != null) { // note! not .next
            if (one.value &lt; two.value) {
                curr.next = one;
                one = one.next;
            } else {
                curr.next = two;
                two = two.next;
            }
            curr = curr.next; // note! need to Accelerator
        }
        if (one != null) { // note! if not while
            curr.next = one;
        }
        if (two != null) {
            curr.next = two;
        }
        return dummyHead.next;
    }
</code></pre>
<blockquote>
<p>reorder the linkedlist<br>
1ï¼‰éœ€è¦æ‰¾åˆ°middle nodeï¼Œç„¶åreverseå‰©ä¸‹éƒ¨åˆ†<br>
2ï¼‰ä¸€åˆ†ä¸ºäºŒï¼Œä¸€æ¬¡ä»å‰åŠéƒ¨åˆ†æ’ï¼Œä¸€æ¬¡ä»ååŠéƒ¨åˆ†æ’<br>
double duume head : partition the linkedlist, small -&gt; large<br>
1ï¼‰æœ¬é¢˜æ˜¯dummyheadçš„é›†å¤§æˆï¼Œå®šä¹‰dummyheadä¸€å®šè¦å®šä¹‰curr Nodeï¼Œæ¯æ¬¡éƒ½è¦ç§»åŠ¨<br>
2ï¼‰æ³¨æ„ç»™æŸäº›é“¾è¡¨ç»“å°¾èµ‹å€¼null</p>
</blockquote>
<blockquote></blockquote>
<h1 id="iteration-vs-recursive">iteration VS recursive</h1>
<blockquote>
<p>æˆ‘ä»¬çŸ¥é“ï¼Œå¾ªç¯åœ¨ä¸€å®šç¨‹åº¦ä¸Šå¯ä»¥ç­‰ä»·äºé€’å½’ï¼Œä½†æ˜¯ä¸¤è€…åœ¨ä½¿ç”¨åœºæ™¯ä»æœ‰åŒºåˆ«</p>
</blockquote>
<ol>
<li>iteration: å½“åœ¨æ•°ç»„ä¸­éå†æ—¶ï¼Œä¸€èˆ¬é‡‡ç”¨æ­¤ç§æ–¹æ³•ï¼›</li>
<li>recursiveçš„æœ¬è´¨æ˜¯å¯»æ‰¾æ›´å°çš„å­é›†ï¼Œæ‰€ä»¥æ­¤ç§æ–¹æ³•æ›´é€‚ç”¨äºlinked listï¼Œå› ä¸ºarrayçš„ç‰¹æ€§æ˜¯é€šè¿‡ä¸‹è¡¨è®¿é—®è€Œæ— æ³•åˆ†åˆ«è¡¨ç¤ºæ•°ç»„ä¸­çš„ä¸¤ä¸ªå­æ•°ç»„ï¼Œè€Œlinked liståˆ™ä¸ä¸€æ ·ï¼Œå¯ä»¥é€šè¿‡ä¸åŒå¤´å°¾æŒ‡é’ˆçš„è®¾å®šç¡®å®šæ–°çš„list</li>
</ol>
<h1 id="å¤šæŒ‡é’ˆé—®é¢˜">å¤šæŒ‡é’ˆé—®é¢˜</h1>
<ol>
<li>å¤šæŒ‡é’ˆé—®é¢˜å¤šç”¨äºåˆ’åˆ†åŒºåŸŸï¼Œå¯èµ·åˆ°æŒ¡æ¿çš„ä½œç”¨</li>
<li>åœ¨å¾ªç¯ä½“å†…çš„æ§åˆ¶æ¡ä»¶ï¼Œä¸€èˆ¬ç”¨ &lt;=ï¼Œ è€Œä¸ç”¨ !=, å› ä¸ºæœ‰å¯èƒ½ä¸€æ¬¡ç§»åŠ¨ä¸¤ä¸ªä½ç½®ä½¿å¾—æŒ‡é’ˆæ°¸è¿œä¸æƒ³ç­‰ä»è€Œè¶Šç•Œ</li>
<li>ç»å…¸äºŒåˆ†é—®é¢˜ï¼Œå…¶å¾ªç¯ä½“å†…ä¹Ÿæ˜¯&lt;=, mid = left + (right - left) / 2ï¼Œå³æœ€åleft = rightï¼› ä½†æ˜¯äºŒåˆ†çš„å˜ç§ä¸ä¸€å®šä¿è¯å…¶å¾ªç¯ä½“å†…çš„æ§åˆ¶æ¡ä»¶ï¼Œæœ‰å¯èƒ½æ˜¯&lt;ï¼Œå³leftä¸rightå·®ä¸€ä¸ªå…ƒç´ çš„ä½ç½®, è¦æ ¹æ®é¢˜ç›®æ„æ€æ¥å®šï¼›</li>
</ol>
<h1 id="javaæœ‰ç”¨çš„api">Javaæœ‰ç”¨çš„API</h1>
<ol>
<li>è¡¨ç¤º double(0.0, 1.0]çš„éšæœºæ•°ï¼ŒMath.random()</li>
<li>æ•°ç»„å®¹é‡ä¸å¤Ÿéœ€è¦æ‰©å……æ•°ç»„ï¼Œæ­¤æ—¶éœ€è¦æ•°ç»„çš„å¤åˆ¶æ“ä½œ<pre><code> if (size == array.length) {
         array = Arrays.copyOf(array, (int)(array.length * 1.5));
     }
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sorting Problems]]></title>
        <id>https://cui36.github.io/post/sorting-problems/</id>
        <link href="https://cui36.github.io/post/sorting-problems/">
        </link>
        <updated>2022-08-09T00:08:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="selection-sort">Selection Sort</h1>
<blockquote>
<p>å…¸å‹çš„n^2ç®—æ³•ï¼Œæ³¨æ„å¤–å±‚éå†å¾ªç¯çš„æ—¶å€™åˆ°n-1ç»“æŸ</p>
</blockquote>
<pre><code>public class Solution {
  public int[] solve(int[] array) {
    for (int i = 0; i &lt; array.length - 1; i++) { // iteration times
      int globalMin = i;
      for (int j = i + 1; j &lt; array.length; j++) { // find the K-least element each time
        if (array[j] &lt; array[globalMin]) globalMin = j;
      }
      // swap
      int temp = array[i];
      array[i] = array[globalMin];
      array[globalMin] = temp;
    }
    return array;
  }
}
</code></pre>
<h1 id="merge-sort">Merge Sort</h1>
<blockquote>
<p>å…¸å‹çš„n*lognç®—æ³•ï¼Œå…¶åˆ†ä¸ºä¸¤éƒ¨åˆ†:<br>
1ï¼‰divide<br>
time = 1 + 2 + 4 + ... + n / 2ï¼›ç¬¬ä¸€å±‚å°†arrayåˆ†ä¸ºä¸¤æ¬¡ï¼Œç¬¬äºŒå±‚åˆ†ä¸º4æ¬¡...<br>
2ï¼‰conquer<br>
time = n * lognï¼›å½“divideå®Œæˆï¼Œleftæ˜¯å•ä¸ªå…ƒç´ ï¼Œæ¯æ¬¡conqueråä¼šç»™leftå¢åŠ æ–°çš„å…ƒç´ ã€‚æ¯æ¬¡divideåˆ°æœ€å°å…ƒç´ åå°±conquer,<br>
3ï¼‰space = stack + heap = recursion_level + extra space = logn + (n/2 + n/4 + ... + 1) = O(n)</p>
</blockquote>
<pre><code>import java.util.Arrays;

public class MergeSort {
    public int[] mergeSort(int[] array) {
        if (array == null || array.length &lt;= 1) return array;
        return mergeSort(array, 0, array.length - 1);
    }
    private int[] mergeSort(int[] array, int left, int right) {
        if (left == right) return new int[]{array[left]};
        // recursive rule
        int mid = left + (right - left) / 2;
        int[] leftResult = mergeSort(array, left, mid);
        int[] rightResult = mergeSort(array, mid + 1, right);
        return merge(leftResult, rightResult);
    }
    public int[] merge(int[] leftResult, int[] rightResult) {
        int[] result = new int[leftResult.length + rightResult.length];
        int leftIndex = 0;
        int rightIndex = 0;
        int resultIndex = 0;
        while (leftIndex &lt; leftResult.length &amp;&amp; rightIndex &lt; rightResult.length) {
            if (leftResult[leftIndex] &lt;= rightResult[rightIndex]) {
                result[resultIndex++] = leftResult[leftIndex++];
            }
            else {
                result[resultIndex++] = rightResult[rightIndex++];
            }
        }
        while (leftIndex &lt; leftResult.length) {
            result[resultIndex++] = leftResult[leftIndex++];
        }
        while (rightIndex &lt; rightResult.length) {
            result[resultIndex++] = rightResult[rightIndex++];
        }
        return result;
    }
    public static void main(String[] args) {
        MergeSort solution = new MergeSort();
        int[] array = null;
        array = new int[] {3,5,1,2,4};
        array = solution.mergeSort(array);
        System.out.println(Arrays.toString(array));
    }
}
</code></pre>
<h2 id="ä¸¾ä¸€åäºŒ">ä¸¾ä¸€åäºŒ</h2>
<blockquote>
<p>Merge Sort for Linked List: As slow random access performance, other sorting method is impossible.<br>
1ï¼‰headRef to the head pointer, and it needs to be changed if the head node is not the smallest one.<br>
2ï¼‰divide the linked list to two halves a &amp; b<br>
3ï¼‰MergeSort(a) &amp;&amp; MergeSort(b)<br>
4ï¼‰Merge the Sorted a,b and update the head pointer: headRef = SortedMerge(a, b)</p>
</blockquote>
<pre><code>// æ ¸å¿ƒä»£ç ï¼š
public node mergeSort(node h) {
        // base case
        if (h == null || h.next == null) {
            return h;
        }
        // recursive
        node middle = getMiddle(h);
        node nexttomiddle = middle.next;
        middle.next = null;
        node leftMerge = mergeSort(h);
        node rightMerge = mergeSort(nexttomiddle);
        return merge(leftMerge, rightMerge);
    }
    public node getMiddle(node h) {
        if (h == null) {
            return h;
        }
        node slow = h, fast = h;
        while (fast.next != null &amp;&amp; fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
    node merge(node left, node right) {
        node result = null;
        if (left == null) return right;
        if (right == null) return left;
        if (left.val &lt;= right.val) {
            result = left;
            result.next = merge(left.next, right);
        } else {
            result = right;
            result.next = merge(left, right.next);
        }
        return result;
    }
</code></pre>
<h2 id="ä¸¾ä¸€åä¸‰">ä¸¾ä¸€åä¸‰</h2>
<blockquote>
<p>convert {A, 1, B, 2, C, 3} to {A, B, C, 1, 2, 3}<br>
ğŸ˜µç›®å‰æƒ³åˆ°çš„æ˜¯åœ¨mergeå‡½æ•°ä¸­newä¸¤ä¸ªæ•°ç»„ï¼Œåˆ†åˆ«å¢åŠ ï¼Œç„¶åå†åˆå¹¶</p>
</blockquote>
<h1 id="quick-sort">Quick Sort</h1>
<blockquote>
<p>ç®—æ³•æµç¨‹<br>
1ï¼‰é€‰å–pivotï¼Œå¹¶ä¸”ä¸æœ€åä¸€ä¸ªå…ƒç´ è¿›è¡Œä½ç½®äº’æ¢ï¼›<br>
2ï¼‰å·¦å³åŒæŒ‡é’ˆï¼Œå°†å·¦æŒ‡é’ˆæ¯”pivotå¤§çš„å…ƒç´ ä¸å³æŒ‡é’ˆæ¯”pivptå°çš„å…ƒç´ äº’æ¢ï¼›<br>
3ï¼‰ä¸¤ä¸ªæŒ¡æ¿ï¼Œä¸‰ä¸ªåŒºåŸŸï¼Œ[0, i) æ¯”pivotå°çš„æ•°ï¼Œ[i, j]å°šæœªæ¢ç´¢åŒºåŸŸ,(j, n-1]æ¯”pivotå¤§çš„æ•°ï¼Œåˆ†åˆ«é€’å½’<br>
capacity:<br>
1ï¼‰worst time:<br>
2ï¼‰average time:</p>
</blockquote>
<pre><code>    public int[] quickSort(int[] array) {
        if (array == null || array.length == 0) {
            return array;
        }
        quickSort(array, 0, array.length - 1);
        return array;
    }
    public void quickSort(int[] array, int left, int right) {
        if (left &gt;= right) return;
        // recursive
        int pivotIndex = partition(array, left, right);
        quickSort(array, left, pivotIndex - 1);
        quickSort(array, pivotIndex + 1, right);

    }
    public int partition(int[] array, int left, int right) {
        int pivotIndex = pivotIndex(left, right);
        int pivot = array[pivotIndex];
        // swap the pivot element to the latest
        swap(array, pivotIndex, right);
        int leftBd = left;
        int rightBd = right - 1;
        while (leftBd &lt;= rightBd) {
            if (array[leftBd] &lt; pivot) {
                leftBd ++;
            } else if (array[rightBd] &gt; pivot) {
                rightBd --;
            } else {
                swap(array, leftBd ++, rightBd --);
            }
        }
        swap(array, leftBd, right);
        return leftBd;
    }
    private int pivotIndex(int left, int right) {
        return left + (int)Math.random() * (right - left + 1);
    }
    private void swap(int[] array, int a, int b) {
        int temp = array[a];
        array[a] = array[b];
        array[b] = temp;
    }
</code></pre>
]]></content>
    </entry>
</feed>